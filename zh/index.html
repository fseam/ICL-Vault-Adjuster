<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ICL术后拱高调整策略辅助工具</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        .results-section { border-left: 3px solid #3b82f6; padding-left: 1rem; margin-top: 0.5rem; }
        .results-section h5 { font-weight: 600; color: #1d4ed8; margin-bottom: 0.25rem;}
        .results-section h6 { font-weight: 600; color: #1e40af; margin-top: 0.5rem; margin-bottom: 0.25rem;}
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center py-8 px-4">
    <div class="bg-white p-6 sm:p-8 rounded-xl shadow-2xl w-full max-w-3xl">
        <h1 class="text-2xl sm:text-3xl font-bold text-center text-sky-700 mb-3">
            ICL术后拱高调整策略辅助工具
        </h1>
        <p class="text-xs text-gray-500 mb-3 text-center">
            针对 The EVO Implantable Collamer Lens (ICL Model V4c; STAAR Surgical Inc, Monrovia, CA, USA)
        </p>
        <p class="text-sm text-gray-600 mb-6 text-center">
            本工具基于简化的理论模型，旨在辅助临床医生制定ICL术后拱高调整策略。
            <br>核心原理：利用理论计算的拱高<strong class="text-red-600">变化量</strong>来预测实际临床调整后的拱高<strong class="text-red-600">变化量</strong>。
        </p>

        <div class="space-y-6 mb-6"> 
            <div>
                <h4 class="text-lg font-semibold text-gray-800 border-b pb-2 mb-3">1. 眼部参数</h4>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4">
                    <div>
                        <label for="a_sulcus" class="block text-sm font-medium text-gray-700 mb-1">睫状沟短轴直径 a (STS<sub>h</sub>, mm):</label>
                        <input type="number" id="a_sulcus" step="0.1" class="w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-sky-500 focus:border-sky-500 sm:text-sm" placeholder="例如 11.6">
                    </div>
                    <div>
                        <label for="b_sulcus" class="block text-sm font-medium text-gray-700 mb-1">睫状沟长轴直径 b (STS<sub>v</sub>, mm):</label>
                        <input type="number" id="b_sulcus" step="0.1" class="w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-sky-500 focus:border-sky-500 sm:text-sm" placeholder="例如 12.2">
                    </div>
                    <div class="md:col-span-2"> 
                        <label for="stsl" class="block text-sm font-medium text-gray-700 mb-1">STSL (晶状体前表面-睫状沟平面距离, mm):</label>
                        <input type="number" id="stsl" value="0.5" step="0.01" class="w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-sky-500 focus:border-sky-500 sm:text-sm" placeholder="例如 0.3 - 0.7">
                    </div>
                </div>
            </div>

            <div>
                <h4 class="text-lg font-semibold text-gray-800 border-b pb-2 mb-3">2. 当前ICL参数 (初次手术)</h4>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4">
                    <div>
                        <label for="L_icl_chord_current" class="block text-sm font-medium text-gray-700 mb-1">ICL 标称尺寸 (对角线<strong class="text-blue-600">弦长</strong> L<sub>ICL</sub>, mm):</label>
                        <select id="L_icl_chord_current" class="w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-sky-500 focus:border-sky-500 sm:text-sm" title="厂家提供的标准尺寸">
                            <option value="12.1">12.1 mm</option>
                            <option value="12.6" selected>12.6 mm</option>
                            <option value="13.2">13.2 mm</option>
                            <option value="13.7">13.7 mm</option>
                        </select>
                    </div>
                    <div>
                        <label for="h_intrinsic_current" class="block text-sm font-medium text-gray-700 mb-1">ICL 自身拱高 (h<sub>intrinsic</sub>, mm):</label>
                        <input type="number" id="h_intrinsic_current" value="1.5" step="0.01" class="w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-sky-500 focus:border-sky-500 sm:text-sm" title="例如ICL在BSS中或无约束状态下的自然拱高">
                        <p class="text-xs text-gray-500 mt-1">例如，根据临床实际测量，ICL在BSS中或无约束状态下自身拱高可近似为 1.5 mm。</p>
                    </div>
                    <div>
                        <label for="alpha_ef_deg_current" class="block text-sm font-medium text-gray-700 mb-1">当前ICL轴 ef 与水平夹角 α<sub>current</sub> (度):</label>
                        <input type="number" id="alpha_ef_deg_current" value="0" step="1" class="w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-sky-500 focus:border-sky-500 sm:text-sm" title="初次手术通常为水平放置(0度)">
                    </div>
                    <div>
                        <label for="icl_thickness_current" class="block text-sm font-medium text-gray-700 mb-1">当前ICL 中央厚度 (mm):</label>
                        <input type="number" id="icl_thickness_current" value="0.250" step="0.001" class="w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-sky-500 focus:border-sky-500 sm:text-sm" placeholder="0.200-0.300">
                        <p class="text-xs text-gray-500 mt-1">根据临床测量，ICL中央厚度通常在 0.200 - 0.300 mm 之间。默认采用 0.250 mm。</p>
                    </div>
                    <div class="md:col-span-2">
                        <label for="beta_internal_deg" class="block text-sm font-medium text-gray-700 mb-1">ICL内部对角线与 ef 夹角大小 |β| (度):</label>
                        <input type="number" id="beta_internal_deg" value="24.0" step="0.1" class="w-full px-3 py-2 bg-gray-200 border border-gray-300 rounded-md shadow-sm sm:text-sm" readonly title="此版本中固定">
                        <p class="text-xs text-gray-500 mt-1">此版本中 |β| 为固定值(24.0°)，代表ef轴到ac和bd的夹角大小。</p>
                    </div>
                </div>
            </div>

            <div>
                <h4 class="text-lg font-semibold text-gray-800 border-b pb-2 mb-3">3. 实际术后情况 及 调整相关参数</h4>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4">
                    <div>
                        <label for="actual_postop_vault" class="block text-sm font-medium text-gray-700 mb-1">实际术后拱高 (mm):</label>
                        <input type="number" id="actual_postop_vault" step="0.001" class="w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-sky-500 focus:border-sky-500 sm:text-sm" placeholder="例如: 0.450 (理想范围: 0.250 - 0.750 mm)">
                        <p class="text-xs text-red-500 mt-1 font-semibold">注意: 请以毫米(mm)为单位输入 (例如 1045µm 应输入为 1.045)。</p>
                    </div>
                    <div>
                        <label for="icl_type" class="block text-sm font-medium text-gray-700 mb-1">ICL 类型:</label>
                        <select id="icl_type" class="w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-sky-500 focus:border-sky-500 sm:text-sm">
                            <option value="NonToric">普通ICL (Non-Toric)</option>
                            <option value="TICL">TICL (Toric)</option>
                        </select>
                    </div>
                    <div id="newTiclAngleSection" class="md:col-span-2" style="display: none;"> 
                        <label for="alpha_ef_deg_new_ticl" class="block text-sm font-medium text-gray-700 mb-1">更换新TICL时的预期植入角度 α<sub>new_TICL</sub> (度):</label>
                        <input type="number" id="alpha_ef_deg_new_ticl" value="0" step="1" class="w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-sky-500 focus:border-sky-500 sm:text-sm" title="如果选择更换TICL，请输入新TICL的预期植入角度">
                        <p class="text-xs text-gray-500 mt-1">此角度仅在ICL类型为TICL且建议更换尺寸时用于计算。默认为0度。</p>
                    </div>
                </div>
            </div>
        </div>

        <button id="calculateButton" class="w-full bg-sky-600 hover:bg-sky-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-opacity-50 transition duration-150 ease-in-out">
            获取调整建议
        </button>

        <div id="resultsArea" class="mt-6 sm:mt-8 p-4 sm:p-6 bg-gray-50 rounded-lg shadow-inner min-h-[250px]">
            <h4 class="text-lg font-semibold text-gray-800 mb-3 border-b pb-2">调整建议:</h4>
            <div id="resultsContent" class="text-sm text-gray-700 space-y-2">
                请填入所有参数并点击按钮。
            </div>
        </div>
    </div>

    <script>
        const BETA_INTERNAL_DEG_DEFAULT = 24.0;
        const ICL_SIZES_MM = [12.1, 12.6, 13.2, 13.7]; 
        const IDEAL_VAULT_MIN_MM = 0.250;
        const IDEAL_VAULT_MAX_MM = 0.750;
        const TARGET_VAULT_MM = 0.500;

        function solveNewton(func, derivative, initialGuess, tolerance = 1e-9, maxIterations = 100) {
            let x = initialGuess;
            for (let i = 0; i < maxIterations; i++) {
                const fx = func(x);
                const fpx = derivative(x);
                if (Math.abs(fpx) < 1e-12) return NaN;
                const xNext = x - fx / fpx;
                if (Math.abs(xNext - x) < tolerance) return xNext;
                x = xNext;
            }
            return NaN;
        }

        function calculateArcLengthFromChordAndVault(chord, vault_intrinsic) {
            if (vault_intrinsic < 0 || chord <= 0) {
                 return { error: "ICL自身拱高不能为负，ICL标称尺寸(弦长)必须为正。" };
            }
            if (Math.abs(vault_intrinsic) < 1e-9) { 
                return { arcLength: chord, R_intrinsic: Infinity, x_intrinsic_rad: 0 };
            }
            if (vault_intrinsic * 2 >= chord) { 
                 return { error: "ICL自身拱高过大 (等于或大于弦长的一半)，无法形成有效圆弧或公式不适用。" };
            }
            const H = vault_intrinsic;
            const C = chord;
            const R_intrinsic = (H / 2) + (C * C) / (8 * H);
            if (R_intrinsic < H || R_intrinsic < C/2 ) {
                 return { error: "从弦长和自身拱高计算得到的固有半径R不合理。" };
            }
            const cos_x_val = 1 - H / R_intrinsic;
            let x_intrinsic_rad;
            if (cos_x_val < -1.00000001 || cos_x_val > 1.00000001) { 
                 return { error: `计算自身半角x时cos值(${cos_x_val.toFixed(6)})超出范围[-1, 1]。` };
            }
            const clamped_cos_x_val = Math.max(-1, Math.min(1, cos_x_val));
            x_intrinsic_rad = Math.acos(clamped_cos_x_val);
            
            const S_calculated = R_intrinsic * 2 * x_intrinsic_rad;
            return { arcLength: S_calculated, R_intrinsic: R_intrinsic, x_intrinsic_rad: x_intrinsic_rad };
        }

        function getSulcusChordLength(r_x_sulcus, r_y_sulcus, phi_deg_horizontal) {
            const phi_rad_horizontal = phi_deg_horizontal * (Math.PI / 180);
            const cos_phi_sq = Math.cos(phi_rad_horizontal) ** 2;
            const sin_phi_sq = Math.sin(phi_rad_horizontal) ** 2;
            const numerator_rho_sq = (r_x_sulcus ** 2 * r_y_sulcus ** 2);
            const denominator_rho_sq = (r_y_sulcus ** 2 * cos_phi_sq) + (r_x_sulcus ** 2 * sin_phi_sq);
            if (Math.abs(denominator_rho_sq) < 1e-12) return NaN;
            const rho_sq = numerator_rho_sq / denominator_rho_sq;
            return 2 * Math.sqrt(rho_sq);
        }

        function getGeometricVault(a_sulcus, b_sulcus, alpha_ef_deg, S_icl_arc, beta_internal_abs_deg) {
            const r_x = a_sulcus / 2.0;
            const r_y = b_sulcus / 2.0;

            const phi_deg_ac = alpha_ef_deg - beta_internal_abs_deg;
            const phi_deg_bd = alpha_ef_deg + beta_internal_abs_deg;

            const chord_ac = getSulcusChordLength(r_x, r_y, phi_deg_ac);
            const chord_bd = getSulcusChordLength(r_x, r_y, phi_deg_bd);

            if (isNaN(chord_ac) || isNaN(chord_bd)) {
                 return { error: "计算椭圆弦长时出错。" };
            }

            let dominant_chord, dominant_phi_deg, dominant_diag_name;
            if (chord_ac <= chord_bd) {
                dominant_chord = chord_ac;
                dominant_phi_deg = phi_deg_ac;
                dominant_diag_name = "ac";
            } else {
                dominant_chord = chord_bd;
                dominant_phi_deg = phi_deg_bd;
                dominant_diag_name = "bd";
            }

            if (dominant_chord > S_icl_arc + 1e-9) {
                return { error: `主导睫状沟弦长 (${dominant_chord.toFixed(4)}mm) 大于ICL弧长 (${S_icl_arc.toFixed(4)}mm)。` };
            } else if (Math.abs(dominant_chord - S_icl_arc) < 1e-9) {
                return { h_geom: 0.0, dominant_chord: dominant_chord, dominant_phi_deg: dominant_phi_deg, dominant_diag_name: dominant_diag_name, R_arc: Infinity, theta_arc_deg: 0.0 };
            }

            const k = dominant_chord / S_icl_arc;
            const funcToSolve = (x) => k * x - Math.sin(x);
            const derivativeOfFunc = (x) => k - Math.cos(x);
            let x_initial = Math.PI / 4;
            if (k > 0.95) x_initial = Math.sqrt(6 * (1 - k));
            if (isNaN(x_initial) || x_initial < 1e-6) x_initial = 1e-5;

            let x_solution = solveNewton(funcToSolve, derivativeOfFunc, x_initial);
            if (isNaN(x_solution) || x_solution <= 0 || x_solution >= Math.PI / 2) {
                x_solution = solveNewton(funcToSolve, derivativeOfFunc, 0.01);
                 if (isNaN(x_solution) || x_solution <= 0 || x_solution >= Math.PI / 2) {
                    return { error: "数值求解器未能找到合适的解(x)计算几何弓高。" };
                }
            }
            const theta_arc_rad = 2 * x_solution;
            const R_arc = (Math.abs(theta_arc_rad) < 1e-12) ? Infinity : S_icl_arc / theta_arc_rad;
            const h_geom = R_arc * (1 - Math.cos(x_solution));
            
            return { 
                h_geom: h_geom, 
                dominant_chord: dominant_chord, 
                dominant_phi_deg: dominant_phi_deg, 
                dominant_diag_name: dominant_diag_name,
                R_arc: R_arc, 
                theta_arc_deg: theta_arc_rad * (180 / Math.PI),
                phi_deg_ac: phi_deg_ac, chord_ac: chord_ac,
                phi_deg_bd: phi_deg_bd, chord_bd: chord_bd
            };
        }
        
        const iclTypeSelect = document.getElementById('icl_type');
        const newTiclAngleSection = document.getElementById('newTiclAngleSection');

        function toggleNewTiclAngleSection() {
            if (iclTypeSelect.value === 'TICL') {
                newTiclAngleSection.style.display = 'block';
            } else {
                newTiclAngleSection.style.display = 'none';
            }
        }
        
        toggleNewTiclAngleSection();
        iclTypeSelect.addEventListener('change', toggleNewTiclAngleSection);


        const calculateButton = document.getElementById('calculateButton');
        const resultsContent = document.getElementById('resultsContent');
        document.getElementById('beta_internal_deg').value = BETA_INTERNAL_DEG_DEFAULT;

        calculateButton.addEventListener('click', () => {
            resultsContent.innerHTML = ""; 

            const params = {
                a_sulcus: parseFloat(document.getElementById('a_sulcus').value),
                b_sulcus: parseFloat(document.getElementById('b_sulcus').value),
                stsl: parseFloat(document.getElementById('stsl').value),
                L_icl_chord_current: parseFloat(document.getElementById('L_icl_chord_current').value),
                h_intrinsic_current: parseFloat(document.getElementById('h_intrinsic_current').value),
                alpha_ef_deg_current: parseFloat(document.getElementById('alpha_ef_deg_current').value),
                icl_thickness_current: parseFloat(document.getElementById('icl_thickness_current').value),
                beta_internal_deg: parseFloat(document.getElementById('beta_internal_deg').value),
                actual_postop_vault: parseFloat(document.getElementById('actual_postop_vault').value),
                icl_type: document.getElementById('icl_type').value,
                alpha_ef_deg_new_ticl: parseFloat(document.getElementById('alpha_ef_deg_new_ticl').value)
            };

            for (const key in params) {
                if (isNaN(params[key]) && key !== 'icl_type') {
                    resultsContent.innerHTML = `<p class="text-red-600 font-medium">错误: 输入值 "${key}" 无效或缺失。</p>`;
                    return;
                }
            }
            // Input validation for negative actual_postop_vault
            if (params.actual_postop_vault < 0) {
                 resultsContent.innerHTML = `<p class="text-red-600 font-medium">错误: "实际术后拱高" (${(params.actual_postop_vault * 1000).toFixed(1)} µm) 不能为负数。这是一个异常的临床情况，请核实输入值。</p>`;
                return;
            }
            if (params.stsl < 0 || params.icl_thickness_current < 0) {
                 resultsContent.innerHTML = `<p class="text-red-600 font-medium">错误: STSL 和 ICL 中央厚度不能为负数。</p>`;
                return;
            }
            
            const arcResultCurrent = calculateArcLengthFromChordAndVault(params.L_icl_chord_current, params.h_intrinsic_current);
            if (arcResultCurrent.error) {
                resultsContent.innerHTML = `<p class="text-red-600 font-medium">计算当前ICL弧长时出错: ${arcResultCurrent.error}</p>`;
                return;
            }
            const S_icl_arc_current = arcResultCurrent.arcLength;
            
            let initialInfoHtml = `<div class="results-section"><h5>初始状态分析:</h5><p class="text-xs text-gray-600">当前ICL (L<sub>ICL</sub>=${params.L_icl_chord_current.toFixed(2)}mm, h<sub>int</sub>=${params.h_intrinsic_current.toFixed(2)}mm) 计算弧长 S<sub>calc</sub> = ${S_icl_arc_current.toFixed(4)}mm.</p>`;

            const geomResultInitial = getGeometricVault(params.a_sulcus, params.b_sulcus, params.alpha_ef_deg_current, S_icl_arc_current, params.beta_internal_deg);
            if (geomResultInitial.error) {
                resultsContent.innerHTML = initialInfoHtml + `<p class="text-red-600 font-medium">计算初始理论几何弓高时出错: ${geomResultInitial.error}</p></div>`;
                return;
            }
            const h_geom_initial = geomResultInitial.h_geom;
            const theoretical_clinical_vault_initial = h_geom_initial - params.icl_thickness_current - params.stsl;

            initialInfoHtml += `<p class="text-xs text-gray-600">在 α=${params.alpha_ef_deg_current.toFixed(1)}° 时, 主导对角线 '${geomResultInitial.dominant_diag_name}' (φ=${geomResultInitial.dominant_phi_deg.toFixed(1)}°), 跨越弦长 c'=${geomResultInitial.dominant_chord.toFixed(4)}mm.</p>`;
            initialInfoHtml += `<p class="text-xs text-gray-600">初始理论几何弓高 (h<sub>geom_initial</sub>): ${h_geom_initial.toFixed(4)} mm.</p>`;
            initialInfoHtml += `<p class="text-xs text-gray-600">初始理论临床拱高 (h<sub>geom_initial</sub> - 厚度 - STSL): ${theoretical_clinical_vault_initial.toFixed(4)} mm.</p></div>`;
            resultsContent.innerHTML = initialInfoHtml;


            let suggestionsHtml = "";
            if (params.actual_postop_vault >= IDEAL_VAULT_MIN_MM && params.actual_postop_vault <= IDEAL_VAULT_MAX_MM) {
                suggestionsHtml = `<div class="results-section mt-4"><h5>评估结果:</h5><p class="text-green-600 font-semibold">当前实际术后拱高 (${(params.actual_postop_vault * 1000).toFixed(1)} µm) 在理想范围 (${(IDEAL_VAULT_MIN_MM * 1000).toFixed(0)} - ${(IDEAL_VAULT_MAX_MM * 1000).toFixed(0)} µm) 内。拱高良好，通常无需调整。</p></div>`;
            } else {
                suggestionsHtml = `<div class="results-section mt-4"><h5>评估结果:</h5><p class="text-orange-600 font-semibold">当前实际术后拱高 (${(params.actual_postop_vault * 1000).toFixed(1)} µm) 超出理想范围 (${(IDEAL_VAULT_MIN_MM * 1000).toFixed(0)} - ${(IDEAL_VAULT_MAX_MM * 1000).toFixed(0)} µm)。建议调整。</p>`;
                
                let delta_theoretical_clinical_vault; 
                let predicted_new_actual_vault;

                if (params.icl_type === "TICL") {
                    suggestionsHtml += `<div class="results-section"><h5>调整建议 (TICL):</h5><p>TICL无法通过旋转调整拱高，建议更换ICL尺寸。</p>`;
                    let new_L_icl_chord;
                    const currentIndex = ICL_SIZES_MM.indexOf(params.L_icl_chord_current);

                    if (params.actual_postop_vault < IDEAL_VAULT_MIN_MM) {
                        if (currentIndex === -1) { suggestionsHtml += `<p class="text-red-500">当前ICL尺寸未在标准列表，无法自动建议新尺寸。</p>`; }
                        else if (currentIndex === ICL_SIZES_MM.length - 1) { suggestionsHtml += `<p class="text-red-500">当前ICL已是最大尺寸，无法更换为更大尺寸。</p>`;}
                        else { new_L_icl_chord = ICL_SIZES_MM[currentIndex + 1]; }
                    } else { 
                        if (currentIndex === -1) { suggestionsHtml += `<p class="text-red-500">当前ICL尺寸未在标准列表，无法自动建议新尺寸。</p>`; }
                        else if (currentIndex === 0) { suggestionsHtml += `<p class="text-red-500">当前ICL已是最小尺寸，无法更换为更小尺寸。</p>`;}
                        else { new_L_icl_chord = ICL_SIZES_MM[currentIndex - 1]; }
                    }

                    if (new_L_icl_chord) {
                        const arcResultNewSize = calculateArcLengthFromChordAndVault(new_L_icl_chord, params.h_intrinsic_current); 
                        if (arcResultNewSize.error) {
                             suggestionsHtml += `<p class="text-red-500">计算新尺寸ICL弧长时出错: ${arcResultNewSize.error}</p>`;
                        } else {
                            const S_icl_arc_new_size = arcResultNewSize.arcLength;
                            const geomResultNewSize = getGeometricVault(params.a_sulcus, params.b_sulcus, params.alpha_ef_deg_new_ticl, S_icl_arc_new_size, params.beta_internal_deg);
                            
                            if (geomResultNewSize.error) {
                                suggestionsHtml += `<p class="text-red-500">计算新尺寸理论几何弓高(在新角度 ${params.alpha_ef_deg_new_ticl.toFixed(1)}°)时出错: ${geomResultNewSize.error}</p>`;
                            } else {
                                const h_geom_new_size = geomResultNewSize.h_geom;
                                const theoretical_clinical_vault_new_size = h_geom_new_size - params.icl_thickness_current - params.stsl; 
                                delta_theoretical_clinical_vault = theoretical_clinical_vault_new_size - theoretical_clinical_vault_initial;
                                predicted_new_actual_vault = params.actual_postop_vault + delta_theoretical_clinical_vault;
                                
                                suggestionsHtml += `<p>建议将ICL尺寸从 ${params.L_icl_chord_current}mm 更换为 ${new_L_icl_chord}mm (新TICL预期植入角度 α=${params.alpha_ef_deg_new_ticl.toFixed(1)}°)。</p>`;
                                suggestionsHtml += `<p>预计临床拱高将${delta_theoretical_clinical_vault >= 0 ? '增加' : '减少'}约 <strong class="text-blue-600">${Math.abs(delta_theoretical_clinical_vault * 1000).toFixed(0)} µm</strong>。</p>`;
                                suggestionsHtml += `<p>预估新临床拱高约为: <strong class="text-emerald-600">${(predicted_new_actual_vault * 1000).toFixed(1)} µm</strong>。</p>`;
                            }
                        }
                    }
                    suggestionsHtml += `</div>`;
                } 
                else if (params.icl_type === "NonToric") {
                    suggestionsHtml += `<div class="results-section"><h5>调整建议 (普通ICL):</h5>`;
                    
                    suggestionsHtml += `<div class="results-section"><h6>方案一: 旋转ICL (优先考虑)</h6>`;
                    const target_actual_vault_change = TARGET_VAULT_MM - params.actual_postop_vault;
                    const target_theoretical_clinical_vault_new = theoretical_clinical_vault_initial + target_actual_vault_change;
                    
                    let best_rotation_alpha = params.alpha_ef_deg_current;
                    let min_diff_to_target_theoretical_clinical_vault = Infinity;
                    let best_predicted_new_actual_vault_rotation = params.actual_postop_vault;
                    let best_delta_theoretical_clinical_rotation = 0;
                    let found_optimal_rotation = false;

                    const candidate_alphas = [];
                    for (let i = 0; i <= 90; i += 5) { candidate_alphas.push(i); }
                    [0, params.beta_internal_deg, 45, 90 - params.beta_internal_deg, 90].forEach(a => {
                        const angle = Math.round(a); 
                        if (!candidate_alphas.includes(angle) && angle >=0 && angle <=90) candidate_alphas.push(angle);
                    });
                    candidate_alphas.sort((a,b) => a-b);

                    for (const alpha_new of candidate_alphas) {
                        if (alpha_new === params.alpha_ef_deg_current) continue; 
                        const geomResultRotated = getGeometricVault(params.a_sulcus, params.b_sulcus, alpha_new, S_icl_arc_current, params.beta_internal_deg);
                        if (!geomResultRotated.error) {
                            const h_geom_rotated = geomResultRotated.h_geom;
                            const theoretical_clinical_vault_rotated = h_geom_rotated - params.icl_thickness_current - params.stsl;
                            const current_diff = Math.abs(theoretical_clinical_vault_rotated - target_theoretical_clinical_vault_new);

                            if (current_diff < min_diff_to_target_theoretical_clinical_vault) {
                                min_diff_to_target_theoretical_clinical_vault = current_diff;
                                best_rotation_alpha = alpha_new;
                                best_delta_theoretical_clinical_rotation = theoretical_clinical_vault_rotated - theoretical_clinical_vault_initial;
                                best_predicted_new_actual_vault_rotation = params.actual_postop_vault + best_delta_theoretical_clinical_rotation;
                                found_optimal_rotation = true;
                            }
                        }
                    }

                    if (found_optimal_rotation) {
                        let stability_comment = "";
                        const beta = params.beta_internal_deg;
                        if ((best_rotation_alpha >= 0 && best_rotation_alpha <= beta) || (best_rotation_alpha >= (90-beta) && best_rotation_alpha <= 90)) {
                            stability_comment = "(此角度通常具有较好旋转稳定性)";
                        } else if (best_rotation_alpha > beta && best_rotation_alpha < (90-beta)) {
                             stability_comment = "(注意: 此角度可能旋转稳定性稍差)";
                        }
                        suggestionsHtml += `<p>建议将ICL旋转至 ef 轴与水平方向呈 <strong class="text-blue-600">${best_rotation_alpha.toFixed(1)}°</strong> ${stability_comment}。</p>`;
                        suggestionsHtml += `<p>预计临床拱高将${best_delta_theoretical_clinical_rotation >= 0 ? '增加' : '减少'}约 <strong class="text-blue-600">${Math.abs(best_delta_theoretical_clinical_rotation * 1000).toFixed(0)} µm</strong>。</p>`;
                        suggestionsHtml += `<p>预估新临床拱高约为: <strong class="text-emerald-600">${(best_predicted_new_actual_vault_rotation * 1000).toFixed(1)} µm</strong>。</p>`;
                    } else {
                        suggestionsHtml += `<p class="text-orange-500">未能通过旋转找到明显更优的拱高方案，或计算出错。</p>`;
                    }
                    suggestionsHtml += `</div>`;

                    suggestionsHtml += `<div class="results-section mt-3"><h6>方案二: 更换ICL尺寸</h6>`;
                    let new_L_icl_chord_nontoric;
                    const currentIndex_nontoric = ICL_SIZES_MM.indexOf(params.L_icl_chord_current);

                    if (params.actual_postop_vault < TARGET_VAULT_MM) { 
                        if (currentIndex_nontoric === -1) {suggestionsHtml += `<p class="text-orange-500">当前ICL尺寸未在标准列表，无法自动建议新尺寸。</p>`;}
                        else if (currentIndex_nontoric === ICL_SIZES_MM.length - 1) { suggestionsHtml += `<p class="text-orange-500">当前ICL已是最大尺寸，无法建议更大尺寸。</p>`;}
                        else { new_L_icl_chord_nontoric = ICL_SIZES_MM[currentIndex_nontoric + 1]; }
                    } else if (params.actual_postop_vault > TARGET_VAULT_MM) { 
                        if (currentIndex_nontoric === -1) {suggestionsHtml += `<p class="text-orange-500">当前ICL尺寸未在标准列表，无法自动建议新尺寸。</p>`;}
                        else if (currentIndex_nontoric === 0) { suggestionsHtml += `<p class="text-orange-500">当前ICL已是最小尺寸，无法建议更小尺寸。</p>`;}
                        else { new_L_icl_chord_nontoric = ICL_SIZES_MM[currentIndex_nontoric - 1]; }
                    } else {
                         suggestionsHtml += `<p>当前拱高已接近目标值 ${TARGET_VAULT_MM.toFixed(3)}mm，通常无需更换尺寸。</p>`;
                    }

                    if (new_L_icl_chord_nontoric) {
                        const arcResultNewSizeNT = calculateArcLengthFromChordAndVault(new_L_icl_chord_nontoric, params.h_intrinsic_current);
                        if (arcResultNewSizeNT.error) {
                             suggestionsHtml += `<p class="text-red-500">计算新尺寸ICL弧长时出错: ${arcResultNewSizeNT.error}</p>`;
                        } else {
                            const S_icl_arc_new_sizeNT = arcResultNewSizeNT.arcLength;
                            const geomResultNewSizeNT = getGeometricVault(params.a_sulcus, params.b_sulcus, 0, S_icl_arc_new_sizeNT, params.beta_internal_deg); 
                            
                            if (geomResultNewSizeNT.error) {
                                suggestionsHtml += `<p class="text-red-500">计算新尺寸理论几何弓高时出错: ${geomResultNewSizeNT.error}</p>`;
                            } else {
                                const h_geom_new_sizeNT = geomResultNewSizeNT.h_geom;
                                const theoretical_clinical_vault_new_sizeNT = h_geom_new_sizeNT - params.icl_thickness_current - params.stsl;
                                
                                const geomResultInitialAtZero = getGeometricVault(params.a_sulcus, params.b_sulcus, 0, S_icl_arc_current, params.beta_internal_deg);
                                let theoretical_clinical_vault_initial_at_zero = theoretical_clinical_vault_initial; 
                                if (!geomResultInitialAtZero.error) {
                                    theoretical_clinical_vault_initial_at_zero = geomResultInitialAtZero.h_geom - params.icl_thickness_current - params.stsl;
                                }

                                delta_theoretical_clinical_vault = theoretical_clinical_vault_new_sizeNT - theoretical_clinical_vault_initial_at_zero;
                                predicted_new_actual_vault = params.actual_postop_vault + delta_theoretical_clinical_vault; 
                                
                                suggestionsHtml += `<p>建议将ICL尺寸从 ${params.L_icl_chord_current}mm 更换为 ${new_L_icl_chord_nontoric}mm (并水平放置)。</p>`;
                                suggestionsHtml += `<p>预计临床拱高将${delta_theoretical_clinical_vault >= 0 ? '增加' : '减少'}约 <strong class="text-blue-600">${Math.abs(delta_theoretical_clinical_vault * 1000).toFixed(0)} µm</strong>。</p>`;
                                suggestionsHtml += `<p>预估新临床拱高约为: <strong class="text-emerald-600">${(predicted_new_actual_vault * 1000).toFixed(1)} µm</strong>。</p>`;
                            }
                        }
                    }
                    suggestionsHtml += `</div>`; 
                    suggestionsHtml += `</div>`; 
                }
            }
            resultsContent.innerHTML += suggestionsHtml;
        });
    </script>
</body>
</html>
